---
title: "服务器与客户端通讯方式"
date: 2025-06-24T17:07:00+08:00
tags: ["文档"]
categories: ["文档"]


featured_image: "https://w.wallhaven.cc/full/d8/wallhaven-d85ewm.png"
description: "服务器与客户端通讯方式"
comment : true
hidden: false
draft: false
---

客户端（Client）和服务器（Server）之间的通信方式有很多种，可以从不同的层面来理解。下面我将从**Web开发中最常见的模式**讲起，再扩展到**更底层的协议**和其他**系统架构中的通信方式**。

### 一、 Web应用中常见的通信模式

这些是前端和后端通信时最常遇到的方式，主要解决“如何获取和更新数据”的问题。

#### 1. 请求-响应模式 (Request-Response)

这是最基础、最核心的模式，也是整个 Web 的基石。

*   **工作方式**：客户端发起一个请求（Request），服务器处理后返回一个响应（Response）。每次通信都由客户端发起，服务器不能主动联系客户端。
*   **典型协议**：**HTTP/1.1**
*   **特点**：
    *   **无状态**：服务器不保留之前请求的任何信息（除非使用 Session 或 Cookie）。
    *   **简单直接**：易于理解和实现。
*   **适用场景**：绝大多数的网页浏览、API 调用、表单提交等。

#### 2. 轮询 (Polling)

为了解决请求-响应模式中服务器无法主动推送数据的问题，轮询是一种简单粗暴的模拟方案。

*   **工作方式**：客户端通过 JavaScript 定时器（如 `setInterval`），每隔一个固定的时间（例如 2 秒）就向服务器发送一次请求，询问“有没有新数据？”。
*   **特点**：
    *   **实现简单**：前端一个定时器即可。
    *   **资源浪费**：无论服务器有无新数据，客户端都会持续发送请求，造成大量无效的网络流量和服务器压力。
    *   **延迟较高**：数据的更新最多会有“一个轮询间隔”的延迟。
*   **适用场景**：对实时性要求不高，但需要自动更新数据的后台管理页面等。

#### 3. 长轮询 (Long Polling)

这是对普通轮询的优化，旨在减少无效请求。

*   **工作方式**：
    1.  客户端向服务器发送请求。
    2.  服务器**不立即响应**，而是保持连接打开（hold the connection）。
    3.  直到服务器**有新数据**时，才将数据返回给客户端，然后关闭连接。
    4.  客户端收到响应后，立即再次发起一个新的长轮询请求。
*   **特点**：
    *   **减少了无效请求**：相比轮询，没有数据时不会有频繁的通信。
    *   **实时性更好**：数据几乎可以立即被推送给客户端。
    *   **服务器资源消耗**：长时间保持连接会对服务器造成一定的压力。
*   **适用场景**：一些早期的 Web 聊天室、实时通知系统。

#### 4. WebSocket

这是一种真正意义上的**全双工通信（Full-duplex）**技术，彻底解决了服务器无法主动通信的问题。

*   **工作方式**：
    1.  客户端通过一个特殊的 HTTP 请求（带有 `Upgrade: websocket` 头）与服务器进行“握手”。
    2.  握手成功后，该连接就从 HTTP "升级" 为 WebSocket 连接。
    3.  之后，客户端和服务器都可以在这个**持久化的连接**上随时互相发送数据。
*   **特点**：
    *   **真正双向通信**：服务器和客户端地位平等，可随时互相发送消息。
    *   **低延迟、高性能**：连接建立后，数据帧的头部信息很小，开销低。
    *   **有状态**：连接是持久的，服务器需要管理这些连接状态。
*   **适用场景**：在线游戏、实时聊天应用、协同编辑（如 Google Docs）、金融股票报价等。

#### 5. 服务器发送事件 (Server-Sent Events, SSE)

这是一种轻量级的**服务器到客户端**的单向通信技术。

*   **工作方式**：客户端发起一个请求，服务器保持该连接，并可以**持续地、单向地**向客户端推送数据流（text/event-stream）。
*   **特点**：
    *   **单向通信**：只能从服务器推向客户端。
    *   **轻量简单**：基于标准 HTTP，客户端 API 非常简单，且支持断线自动重连。
    *   **文本协议**：只能发送文本数据。
*   **适用场景**：只需要接收服务器推送信息的场景，如新闻更新、股票价格推送、系统状态监控等。

---

### 二、 更底层的传输协议

上述所有通信模式最终都依赖于底层的传输协议。

#### 6. TCP (Transmission Control Protocol)

*   **特点**：
    *   **面向连接**：通信前需要建立连接（三次握手）。
    *   **可靠传输**：保证数据不丢失、不重复、按顺序到达。
    *   **有流量控制和拥塞控制**。
*   **应用**：**HTTP、WebSocket、FTP** 等绝大多数需要可靠传输的应用都构建在 TCP 之上。

#### 7. UDP (User Datagram Protocol)

*   **特点**：
    *   **无连接**：发送数据前不需要建立连接。
    *   **不可靠传输**：不保证数据能否到达、是否按序。尽最大努力交付。
    *   **速度快、开销小**。
*   **应用**：对实时性要求极高，但能容忍少量丢包的场景，如**在线游戏的数据同步、视频/音频流传输、DNS 查询**。**HTTP/3 底层的 QUIC 协议就是基于 UDP 实现的**。

---

### 三、 其他重要的通信方式

在更广泛的系统设计（如微服务架构）中，还有其他重要的通信模式。

#### 8. RPC (Remote Procedure Call)

远程过程调用，让客户端调用另一台服务器上的函数就像调用本地函数一样。

*   **工作方式**：客户端调用一个本地的“桩函数”（Stub），这个桩函数负责将调用的方法名和参数打包、序列化，然后通过网络发送给服务器。服务器解包后执行相应函数，再将结果返回。
*   **典型框架**：**gRPC (Google RPC)**, Thrift。gRPC 使用 HTTP/2 作为传输协议，并使用 Protocol Buffers 进行高效序列化。
*   **适用场景**：微服务之间的内部通信，追求高性能和强类型的 API。

#### 9. 消息队列 (Message Queue)

通过一个中间件（消息代理）来解耦客户端（生产者）和服务器（消费者）。

*   **工作方式**：生产者将消息发送到队列中，消费者从队列中拉取并处理消息。生产者和消费者互相不知道对方的存在。
*   **特点**：
    *   **异步通信**：生产者无需等待消费者处理完成。
    *   **解耦**：服务之间没有直接依赖。
    *   **削峰填谷**：可以缓冲突发的高流量，保护后端服务。
*   **典型产品**：RabbitMQ, Kafka, RocketMQ。
*   **适用场景**：日志处理、异步任务（如发送邮件/短信）、系统间数据同步。

### 总结对比

| 通信方式 | 连接方式 | 通信方向 | 主要特点 | 适用场景 |
| :--- | :--- | :--- | :--- | :--- |
| **HTTP 请求-响应** | 短连接/复用连接 | 客户端 -> 服务器 | 简单、无状态、应用最广 | 网页浏览、REST API |
| **轮询** | 短连接 | 客户端 -> 服务器 | 实现简单、资源浪费、有延迟 | 对实时性要求不高的后台更新 |
| **长轮询** | 短暂的长连接 | 客户端 -> 服务器 | 减少无效请求、实时性较好 | 作为 WebSocket 的降级方案、早期聊天室 |
| **WebSocket** | 持久连接 | **双向** | 真正双向、低延迟、高性能 | 实时聊天、在线游戏、协同编辑 |
| **SSE** | 持久连接 | **服务器 -> 客户端** | 轻量、单向、自动重连 | 新闻推送、股票行情、系统通知 |
| **gRPC** | 持久连接(HTTP/2) | 客户端 -> 服务器 | 高性能、基于函数调用、强类型 | 微服务内部通信 |
| **消息队列** | 持久连接 | 生产者 -> 队列 -> 消费者 | 异步、解耦、削峰填谷 | 日志处理、异步任务、系统解耦 |

选择哪种方式，完全取决于你的应用场景对**实时性、性能、复杂度和可靠性**的要求。
